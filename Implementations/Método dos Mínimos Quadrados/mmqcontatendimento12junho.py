# -*- coding: utf-8 -*-
"""MMQContAtendimento12Junho.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RdKTFBVkwNCXPzI_jIvuUIJSK3abvGoq
"""

def matprint(mat, fmt="g"):
    col_maxes = [max([len(("{:"+fmt+"}").format(x)) for x in col]) for col in mat.T]
    for x in mat:
        for i, y in enumerate(x):
            print(("{:"+str(col_maxes[i])+fmt+"}").format(y), end="  ")
        print("")
    print("\n")

import numpy as np
from scipy import linalg as lin
import scipy as sci
import math as m
import matplotlib.pyplot as plt
from sympy import *
import time

def fatoraCholesky(A):

    # definindo matriz H (inicializada com cópia da A)
    H = np.tril(A)  
    n = np.shape(H)[0]  
    
    for i in np.arange(n):
        for k in np.arange(i+1):
            tmp_sum = sum(H[i][j] * H[k][j] for j in np.arange(k))
            
            if (i == k): # Diagonal elements
                # LaTeX: l_{kk} = \sqrt{ a_{kk} - \sum^{k-1}_{j=1} l^2_{kj}}
                H[i][k] = m.sqrt(H[i][k] - tmp_sum)
            else:
                # LaTeX: l_{ik} = \frac{1}{l_{kk}} \left( a_{ik} - \sum^{k-1}_{j=1} l_{ij} l_{kj} \right)
                H[i][k] = (1.0 / H[k][k] * (H[i][k] - tmp_sum))
    
    return H

def sub_regressiva(U,y):
    # U é matriz triangular superior
    # y é o lado direito
    # retornarems a solução

    n = np.shape(y)[0]
    x = np.zeros(n)

    for i in np.arange(n-1,-1,-1): # limite superior:último índice (menor) -1:-1 (step é decremento) --> 4:2:-1 percorre 4 e 3.
        x[i] = (y[i]-U[i,i+1:n].dot(x[i+1:n]))/U[i,i]

    return x

def sub_progressiva(L,b):
    # L é matriz triangular superior
    # b é lado direito
    # retornarems a solução

    n = np.shape(b)[0]
    z = np.zeros(n)

    for i in np.arange(n):
        z[i] = (b[i]-L[i,0:i].dot(z[0:i]))/L[i,i] #z[np.arange(i)] --> percorre até i-1

    return z

"""Exemplo 1:

Aproximar a função $f(x) = e^x$ pela parábola $p(x) = \alpha_0 + \alpha_1 x + \alpha_2 x^2$. Como vimos nas anotações, chegamos no sistema:
\begin{equation}
    \left[ \begin{array}{ccc}
        1 & \frac{1}{2} & \frac{1}{3} \\
        \frac{1}{2} & \frac{1}{3} & \frac{1}{4} \\
        \frac{1}{3} & \frac{1}{4} & \frac{1}{5}
    \end{array} \right] \left[ \begin{array}{c}
        \alpha_0 \\ \alpha_1 \\ \alpha_2
    \end{array} \right] = \left[ \begin{array}{c}
        e-1 \\ 1 \\ e-2
    \end{array} \right]
\end{equation}
"""

A = np.array([[    1.0, 1.0/2.0, 1.0/3.0],  
              [1.0/2.0, 1.0/3.0, 1.0/4.0],
              [1.0/3.0, 1.0/4.0, 1.0/5.0]], dtype='double')
matprint(A);

e = np.exp(1);
b = [e-1,1,e-2];
print(b);

# Usando rotinas do python para resolução de sistema
# alpha = np.linalg.solve(A,b);
# print(alpha)

# Usando nossas rotinas
(H) = fatoraCholesky(A)
z = sub_progressiva(H,b)
alpha = sub_regressiva(np.transpose(H),z)
print(alpha)

p = lambda x: alpha[0] + alpha[1]*x + alpha[2]*x**2;
x = np.linspace(0, 1, num=41, endpoint=True)

# Vamos plotar os resultados
plt.figure(figsize=(10,6),facecolor='white')
plt.plot(x,np.exp(x),label = 'f(x)',linewidth = 3)
plt.plot(x,p(x),label = 'p(x)',linewidth = 2,marker='>')
plt.xlabel('x',fontsize='large') 
plt.ylabel('y',fontsize='large') 
plt.title('Comparação da função aproximada') 
plt.legend(fontsize='large') 
plt.show()

# Vamos aproximar para uma reta usando função do Python
x_data = np.linspace(0,1, num=31, endpoint=True);
y_data = np.exp(x_data);
print(x_data)
print(y_data)

A = np.transpose(np.vstack([x_data, np.ones(len(x_data))]))
matprint(A)
alpha_python = np.linalg.lstsq(A, y_data, rcond=None)[0];
print(alpha_python)

# Vamos plotar os resultados
plt.figure(figsize=(10,6),facecolor='white')
plt.plot(x,np.exp(x),label = 'f(x)',linewidth = 3)
plt.plot(x,alpha_python[0]*x+alpha_python[1],label = 'python(x)',linewidth = 2,marker='>')
plt.xlabel('x',fontsize='large') 
plt.ylabel('y',fontsize='large') 
plt.title('Comparação da função aproximada') 
plt.legend(fontsize='large') 
plt.show()

"""Exemplo 2:

Aproximar a função $f(x) = e^x$ pela função $g(x) = ab^x$. Como vimos nas anotações, chegamos no sistema:
\begin{equation}
    \left[ \begin{array}{cc}
        1 & \frac{1}{2} \\
        \frac{1}{2} & \frac{1}{3}
    \end{array} \right] \left[ \begin{array}{c}
        \alpha_0 \\ \alpha_1
    \end{array} \right] = \left[ \begin{array}{c}
        \frac{1}{2} \\ \frac{1}{3} 
    \end{array} \right]
\end{equation}
"""

A = np.array([[    1.0, 1.0/2.0],  
              [1.0/2.0, 1.0/3.0]], dtype='double')
matprint(A);

e = np.exp(1);
b_vec = [1.0/2.0,1.0/3.0];
print(b_vec);

# Usando rotinas do python para resolução de sistema
alpha = np.linalg.solve(A,b_vec);
print(alpha)

# Usando nossas rotinas
# (H) = fatoraCholesky(A)
# z = sub_progressiva(H,b_vec)
# alpha = sub_regressiva(np.transpose(H),z)
# print(alpha)

# Calculando os coeficientes da aproximação
a = np.exp(alpha[0]); b = np.exp(alpha[1]);
print(a);
print(b);
g = lambda x: a*(b**x);
x = np.linspace(0, 1, num=41, endpoint=True)

# Vamos plotar os resultados
plt.figure(figsize=(10,6),facecolor='white')
plt.plot(x,np.exp(x),label = 'f(x)',linewidth = 3)
plt.plot(x,g(x),label = 'g(x)',linewidth = 2,marker='>')
plt.xlabel('x',fontsize='large') 
plt.ylabel('y',fontsize='large') 
plt.title('Comparação da função aproximada') 
plt.legend(fontsize='large') 
plt.show()

"""Exemplo 3:

Aproximar a função $f(x) = \sin(\pi x)$ pela parábola $p(x) = \alpha_0 + \alpha_1 x + \alpha_2 x^2$. Como vimos nas anotações, chegamos no sistema:
\begin{equation}
    \left[ \begin{array}{ccc}
        1 & \frac{1}{2} & \frac{1}{3} \\
        \frac{1}{2} & \frac{1}{3} & \frac{1}{4} \\
        \frac{1}{3} & \frac{1}{4} & \frac{1}{5}
    \end{array} \right] \left[ \begin{array}{c}
        \alpha_0 \\ \alpha_1 \\ \alpha_2
    \end{array} \right] = \left[ \begin{array}{c}
        \frac{2}{\pi}\\ \frac{1}{\pi^2} \\ \frac{\pi^2 -4}{\pi^3}
    \end{array} \right]
\end{equation}
"""

A = np.array([[    1.0, 1.0/2.0, 1.0/3.0],  
              [1.0/2.0, 1.0/3.0, 1.0/4.0],
              [1.0/3.0, 1.0/4.0, 1.0/5.0]], dtype='double')
matprint(A);

b = [2.0/m.pi,1.0/(m.pi),(m.pi**2 - 4)/(m.pi**3)];
print(b);

# Usando rotinas do python para resolução de sistema
# alpha = np.linalg.solve(A,b);
# print(alpha)

# Usando nossas rotinas
(H) = fatoraCholesky(A)
z = sub_progressiva(H,b)
alpha = sub_regressiva(np.transpose(H),z)
print(alpha)

p = lambda x: alpha[0] + alpha[1]*x + alpha[2]*x**2;
x = np.linspace(0, 1, num=41, endpoint=True)

# Vamos plotar os resultados
plt.figure(figsize=(10,6),facecolor='white')
plt.plot(x,np.sin(m.pi*x),label = 'f(x)',linewidth = 3)
plt.plot(x,p(x),label = 'p(x)',linewidth = 2,marker='>')
plt.xlabel('x',fontsize='large') 
plt.ylabel('y',fontsize='large') 
plt.title('Comparação da função aproximada') 
plt.legend(fontsize='large') 
plt.show()